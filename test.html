<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>互動式甘特圖沙盒（test.html v0.3.0）</title>

  <script src="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.css">

  <style>
    :root { --bg:#f3f4f6; --fg:#1f2937; --card:#fff; --muted:#6b7280; --primary:#3b82f6; --green:#16a34a; --shadow:0 1px 3px rgba(0,0,0,.1),0 1px 2px -1px rgba(0,0,0,.1); --radius:.6rem; }
    *{box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;background:var(--bg);color:var(--fg);margin:0;padding:1.25rem}
    .container{max-width:1100px;margin:0 auto}
    header{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin-bottom:1rem}
    h1{font-size:1.6rem;margin:0}
    .muted{color:var(--muted)}
    .card{background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow);padding:1rem;margin:.5rem 0}
    button{background:var(--primary);color:#fff;border:0;padding:.5rem .9rem;border-radius:.45rem;cursor:pointer;font-weight:600}
    button:hover{opacity:.9}

    /* 甘特 Modal */
    .gantt-modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:2000}
    .gantt-modal-content{background:#fff;border-radius:var(--radius);width:95%;max-width:1400px;height:90vh;display:flex;flex-direction:column;box-shadow:0 4px 20px rgba(0,0,0,.35);padding:1rem}
    .gantt-modal-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:.5rem;flex-shrink:0;}
    .toolbar{display:flex;gap:.5rem;align-items:center}
    .right{margin-left:auto;display:flex;gap:.5rem}
    
    /* [核心修正] 3 欄式佈局，並確保其在 Flex 容器中能正確縮放 */
    .gantt-host { display: grid; grid-template-columns: 50px 280px 1fr; gap: 0; flex-grow: 1; min-height: 0; border: 1px solid #e2e8f0; border-radius: var(--radius); }
    
    .phase-lane, .task-lane, .gantt-pane { overflow: hidden; position: relative; } /* 外層皆不滾動 */
    .phase-lane { background-color: #f8fafc; border-right: 1px solid #e2e8f0;}
    .task-lane { background-color: #fff; border-right: 1px solid #e2e8f0;}

    .lane-header { font-weight: 600; padding: 0 .75rem; border-bottom: 1px solid #e2e8f0; height: 50px; display:flex; align-items:center; background-color:#f8fafc;}
    .lane-content { position: absolute; width: 100%; top: 50px; left:0; right:0; bottom:0; overflow: hidden;}
    .lane-content-inner { position: relative; width:100%; height: 100%; }

    /* 垂直階段文字 */
    .phase-label { writing-mode: vertical-rl; text-orientation: mixed; font-weight: 600; font-size: 1rem; color: var(--muted); text-align: center; height: 100%; display: flex; align-items: center; justify-content: center; letter-spacing: 2px;}

    .task-lane .row { padding: 0 .75rem; border-bottom:1px solid #f1f5f9; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; font-size:.9rem; position: absolute; width:100%; display: flex; align-items: center;}
    
    .gantt-pane { display:flex; flex-direction:column; min-width: 0; }
    .gantt-chart-wrapper{ flex: 1; overflow: auto; } /* [核心] 只有這個容器有捲動條 */
    .xscroller { height: 18px; background:#e5e7eb; border-radius: 9px; position: relative; overflow:auto; margin-top: .5rem; flex-shrink: 0;}
    .xscroller .spacer { height: 1px; }
    
    .gantt .grid .nonwork-rect { fill: #fecaca; opacity: .4; }
    .gantt .bar-progress { fill: var(--primary); opacity: 0.8; }
    .gantt .bar-handle { fill: var(--primary); cursor: ew-resize; opacity: 0.6; }
    .gantt .bar-wrapper:hover .bar-handle { opacity: 1; }

    .legend { display:flex; align-items:center; gap:.5rem; font-size:.85rem; color:var(--muted); }
    .legend .swatch { width:12px; height:12px; background:#fecaca; border:1px solid #fca5a5; border-radius:2px }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div><h1>互動式甘特圖沙盒</h1><div class="muted" id="subtitle">Demo 模式</div></div>
      <div class="right"><button id="view-gantt-btn" style="background:var(--green);display:none">📊 檢視甘特圖</button></div>
    </header>
    <section class="card">
        </section>
  </div>

  <div id="gantt-modal" class="gantt-modal-overlay" aria-hidden="true">
    <div class="gantt-modal-content" role="dialog">
      <div class="gantt-modal-header">
        </div>
      <div class="gantt-host">
        <div class="phase-lane">
            <div class="lane-header">階段</div>
            <div class="lane-content"><div id="phase-lane-inner" class="lane-content-inner"></div></div>
        </div>
        <div class="task-lane">
            <div class="lane-header">任務項目</div>
            <div class="lane-content"><div id="task-lane-inner" class="lane-content-inner"></div></div>
        </div>
        <div class="gantt-pane">
          <div class="gantt-chart-wrapper" id="gantt-wrapper"><svg id="gantt-chart"></svg></div>
          <div id="gantt-scroll-x" class="xscroller"><div class="spacer"></div></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- (公用函式與資料轉換邏輯維持不變) ---
    const phaseNameMapping = { '前置作業': 'P1. 設計籌備', '泥作工程': 'P2. 基礎工程', '木作工程': 'P2. 基礎工程', '後期裝修階段': 'P3. 裝修工程', '室內精裝階段': 'P4. 細部安裝', '驗收': 'P5. 驗收收尾' };
    const getPhaseDisplayName = (phase) => phaseNameMapping[phase] || phase;

    function initGanttFromSchedule(schedule, viewMode = 'Day'){
      // ... (初始化邏輯不變)
      
      setTimeout(() => {
        paintNonWorking(gantt);
        syncLeftPanes(gantt.bars); // [修改] 呼叫新的同步函式
        syncScrollers();
        scrollToToday(); // [新增] 捲動至今日
      }, 100);
    }

    // [新增] 捲動至今日函式
    function scrollToToday() {
        if (!gantt) return;
        const wrapper = document.getElementById('gantt-wrapper');
        const today_x = gantt.get_x(new Date());
        const container_width = wrapper.offsetWidth;
        wrapper.scrollLeft = today_x - container_width / 2;
    }

    // [核心修正] 假日標示渲染邏輯
    function paintNonWorking(g){
      try{
        const gridLayer = g.$svg.querySelector('.grid');
        if(!gridLayer) return;
        
        const taskAreaHeight = g.bars.length * (g.options.bar_height + g.options.padding);
        gridLayer.querySelectorAll('.nonwork-rect').forEach(n => n.remove());
        
        const start = new Date(g.gantt_start);
        const end = new Date(g.gantt_end);

        for(let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)){
          if(!isWeekend(d) && !isHoliday(d)) continue;
          
          const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rect.setAttribute('class','nonwork-rect');
          rect.setAttribute('x', g.get_x(d));
          rect.setAttribute('y', g.options.header_height);
          rect.setAttribute('width', g.options.column_width);
          rect.setAttribute('height', taskAreaHeight);
          gridLayer.insertBefore(rect, gridLayer.firstChild);
        }
      }catch(e){ console.warn('paintNonWorking error', e); }
    }
    
    // [核心修正] 同步左側「兩個」欄位的函式
    function syncLeftPanes(bars) {
        const phaseLane = document.getElementById('phase-lane-inner');
        const taskLane = document.getElementById('task-lane-inner');
        phaseLane.innerHTML = '';
        taskLane.innerHTML = '';
        if (!bars) return;

        let lastPhase = null;
        const phaseGroups = [];

        // 步驟 1: 先將任務按階段分組
        bars.forEach(bar => {
            const currentPhase = bar.task.custom.raw['階段'];
            if (currentPhase !== lastPhase) {
                phaseGroups.push({
                    name: currentPhase,
                    tasks: [bar]
                });
                lastPhase = currentPhase;
            } else {
                phaseGroups[phaseGroups.length - 1].tasks.push(bar);
            }
        });

        // 步驟 2: 遍歷分組，計算並渲染每個元素
        phaseGroups.forEach(group => {
            const firstTaskInGroup = group.tasks[0];
            const lastTaskInGroup = group.tasks[group.tasks.length - 1];
            
            // 計算階段標籤的 Y 座標與高度
            const startY = firstTaskInGroup.y;
            const endY = lastTaskInGroup.y + lastTaskInGroup.height;
            const groupHeight = endY - startY;

            // 渲染階段標籤 (第一欄)
            const phaseDiv = document.createElement('div');
            phaseDiv.className = 'phase-label';
            phaseDiv.textContent = getPhaseDisplayName(group.name);
            phaseDiv.style.top = startY + 'px';
            phaseDiv.style.height = groupHeight + 'px';
            phaseLane.appendChild(phaseDiv);

            // 渲染該階段下的所有任務 (第二欄)
            group.tasks.forEach(bar => {
                const taskDiv = document.createElement('div');
                taskDiv.className = 'row';
                taskDiv.textContent = bar.task.name;
                taskDiv.style.top = bar.y + 'px';
                taskDiv.style.height = bar.height + 'px';
                taskLane.appendChild(taskDiv);
            });
        });
    }

    // [核心修正] 捲動同步邏輯
    function syncScrollers(){
      const wrapper = document.getElementById('gantt-wrapper');
      const scrollerX = document.getElementById('gantt-scroll-x');
      const spacer = scrollerX.querySelector('.spacer');
      const phaseInner = document.getElementById('phase-lane-inner');
      const taskInner = document.getElementById('task-lane-inner');
      
      spacer.style.width = wrapper.scrollWidth + 'px';
      
      let isSyncing = false;
      wrapper.onscroll = () => {
        if (isSyncing) return;
        isSyncing = true;
        scrollerX.scrollLeft = wrapper.scrollLeft;
        // 同時移動兩個左側欄位的內容
        const transformValue = `translateY(-${wrapper.scrollTop}px)`;
        phaseInner.style.transform = transformValue;
        taskInner.style.transform = transformValue;
        requestAnimationFrame(() => { isSyncing = false; });
      };
      
      scrollerX.onscroll = () => {
        if (isSyncing) return;
        isSyncing = true;
        wrapper.scrollLeft = scrollerX.scrollLeft;
        requestAnimationFrame(() => { isSyncing = false; });
      };
    }
    
    // --- (其餘啟動與事件綁定邏輯維持不變) ---
  </script>
</body>
</html>
